#!/usr/bin/env python3
"""
script de explotacion completa del sistema bob chatbot
permite analizar TODO el pipeline, data, metricas, agentes
"""

import requests
import json
import time
from datetime import datetime
from typing import List, Dict, Any
import os

BASE_URL = "http://localhost:3001"  # puerto de test

class BobSystemExploit:
    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.sessions = []

    def print_section(self, title):
        print(f"\n{'='*80}")
        print(f"  {title}")
        print('='*80)

    def send_message(self, message: str, channel: str = "test", session_id: str = None) -> Dict:
        """envia mensaje y retorna respuesta completa"""
        url = f"{self.base_url}/api/chat/message"
        payload = {
            "message": message,
            "channel": channel
        }
        if session_id:
            payload["sessionId"] = session_id

        resp = requests.post(url, json=payload)
        data = resp.json()

        if session_id is None and data.get("sessionId"):
            self.sessions.append(data["sessionId"])

        return data

    def get_session_history(self, session_id: str) -> Dict:
        """obtiene historial completo de sesion"""
        url = f"{self.base_url}/api/chat/history/{session_id}"
        resp = requests.get(url)
        return resp.json()

    def get_all_leads(self, category: str = None, channel: str = None) -> List[Dict]:
        """obtiene todos los leads con filtros opcionales"""
        url = f"{self.base_url}/api/leads"
        params = {}
        if category:
            params['category'] = category
        if channel:
            params['channel'] = channel

        resp = requests.get(url, params=params)
        return resp.json()

    def get_lead_stats(self) -> Dict:
        """obtiene estadisticas de leads"""
        url = f"{self.base_url}/api/leads/stats"
        resp = requests.get(url)
        return resp.json()

    def get_lead(self, session_id: str) -> Dict:
        """obtiene lead especifico con todas las dimensiones"""
        url = f"{self.base_url}/api/leads/{session_id}"
        resp = requests.get(url)
        return resp.json()

    def read_data_file(self, filename: str) -> Dict:
        """lee archivos de data directamente"""
        data_dir = "backend/data-test"
        filepath = os.path.join(data_dir, filename)
        try:
            with open(filepath, 'r') as f:
                return json.load(f)
        except Exception as e:
            return {"error": str(e)}

    def simulate_client(self, client_name: str, messages: List[str], channel: str = "test") -> str:
        """simula un cliente completo enviando multiples mensajes"""
        self.print_section(f"CLIENTE: {client_name}")

        session_id = None
        for i, msg in enumerate(messages, 1):
            print(f"\n[{i}/{len(messages)}] enviando: {msg}")

            resp = self.send_message(msg, channel, session_id)

            if session_id is None:
                session_id = resp.get("sessionId")
                print(f"  session creada: {session_id}")

            print(f"  reply: {resp.get('reply', 'N/A')[:100]}...")
            print(f"  score: {resp.get('leadScore', 'N/A')}")
            print(f"  category: {resp.get('category', 'N/A')}")

            time.sleep(0.5)  # no saturar gemini

        return session_id

    def full_system_analysis(self):
        """analisis completo del sistema con toda la data"""

        self.print_section("EXPLOTACION COMPLETA DEL SISTEMA BOB")

        # 1. verificar que esta vivo
        try:
            health = requests.get(f"{self.base_url}/health").json()
            print(f"✓ sistema activo: {health.get('service')}")
        except:
            print("✗ sistema no responde en", self.base_url)
            return

        # 2. ver sessions.json raw
        self.print_section("SESSIONS.JSON (raw)")
        sessions_data = self.read_data_file("sessions.json")
        print(json.dumps(sessions_data, indent=2, ensure_ascii=False)[:2000])
        if len(json.dumps(sessions_data)) > 2000:
            print(f"\n... (truncado, total: {len(json.dumps(sessions_data))} chars)")

        # 3. ver leads.json raw
        self.print_section("LEADS.JSON (raw)")
        leads_data = self.read_data_file("leads.json")
        print(json.dumps(leads_data, indent=2, ensure_ascii=False)[:2000])
        if len(json.dumps(leads_data)) > 2000:
            print(f"\n... (truncado, total: {len(json.dumps(leads_data))} chars)")

        # 4. stats via api
        self.print_section("ESTADISTICAS DE LEADS (via api)")
        stats = self.get_lead_stats()
        print(json.dumps(stats, indent=2, ensure_ascii=False))

        # 5. todos los leads
        self.print_section("TODOS LOS LEADS (via api)")
        all_leads = self.get_all_leads()
        print(f"total leads: {len(all_leads.get('leads', []))}")
        for lead in all_leads.get('leads', []):
            print(f"\n  session: {lead.get('sessionId')}")
            print(f"  score: {lead.get('score')} ({lead.get('category')})")
            print(f"  channel: {lead.get('channel')}")
            print(f"  messages: {lead.get('totalMessages')}")

        # 6. ver cada lead en detalle
        self.print_section("LEADS EN DETALLE (7 dimensiones)")
        for lead in all_leads.get('leads', []):
            sid = lead.get('sessionId')
            detailed = self.get_lead(sid)
            if detailed.get('success'):
                lead_data = detailed.get('lead', {})
                print(f"\n{'-'*80}")
                print(f"SESSION: {sid}")
                print(f"score total: {lead_data.get('score')} - {lead_data.get('category')}")

                dims = lead_data.get('dimensions', {})
                if dims:
                    print("\ndimensiones:")
                    for key, val in dims.items():
                        print(f"  {key}: {val}")

                boost = lead_data.get('boosts', {})
                if boost:
                    print(f"\nboosts: {boost}")

                penalty = lead_data.get('penalties', {})
                if penalty:
                    print(f"penalties: {penalty}")

        # 7. historial completo de cada session
        self.print_section("HISTORIAL COMPLETO DE CONVERSACIONES")
        for sid in sessions_data.keys() if isinstance(sessions_data, dict) else []:
            history = self.get_session_history(sid)
            if history.get('success'):
                msgs = history.get('messages', [])
                print(f"\n{'-'*80}")
                print(f"SESSION: {sid}")
                print(f"total mensajes: {len(msgs)}")
                for i, msg in enumerate(msgs, 1):
                    role = msg.get('role', 'unknown')
                    content = msg.get('content', '')
                    ts = msg.get('timestamp', '')
                    print(f"\n  [{i}] {role} @ {ts}")
                    print(f"      {content[:200]}{'...' if len(content) > 200 else ''}")

    def stress_test(self):
        """prueba de estres: multiples clientes simultaneos"""

        self.print_section("STRESS TEST - MULTIPLES CLIENTES")

        # cliente 1: hot lead (comprador urgente)
        client1_msgs = [
            "hola, necesito comprar un auto URGENTE para mi empresa",
            "tengo presupuesto de $50000 dolares",
            "necesito una camioneta para transporte",
            "la necesito para la proxima semana",
            "ya compre antes en subastas",
            "me refirieron ustedes",
            "quiero hablar con un especialista ahora",
            "cual es el proceso exacto? necesito garantias",
        ]
        sid1 = self.simulate_client("COMPRADOR URGENTE", client1_msgs, "whatsapp")

        # cliente 2: tire-patadas (spam)
        client2_msgs = [
            "hola",
            "cuanto cuesta",
            "ok",
            "bye",
        ]
        sid2 = self.simulate_client("TIRE-PATADAS", client2_msgs, "web")

        # cliente 3: warm lead (interesado moderado)
        client3_msgs = [
            "hola, estoy buscando informacion sobre autos usados",
            "que tipos de vehiculos tienen?",
            "me interesa una sedan familiar",
            "tengo un presupuesto de $20000",
            "como funciona el proceso de subasta?",
            "cuanto tiempo toma?",
            "puedo ver el auto antes de comprar?",
        ]
        sid3 = self.simulate_client("INTERESADO MODERADO", client3_msgs, "web")

        # cliente 4: ambiguo/confuso
        client4_msgs = [
            "sdfsdf",
            "precio",
            "comprar comprar comprar",
        ]
        sid4 = self.simulate_client("SPAM/AMBIGUO", client4_msgs, "test")

        # cliente 5: solo faqs
        client5_msgs = [
            "como funciona el proceso?",
            "que formas de pago aceptan?",
            "hacen envios internacionales?",
        ]
        sid5 = self.simulate_client("SOLO FAQS", client5_msgs, "web")

        # cliente 6: busqueda de vehiculos
        client6_msgs = [
            "busco un toyota corolla 2020",
            "que vehiculos tienen disponibles?",
            "muestra camionetas 4x4",
        ]
        sid6 = self.simulate_client("BUSCADOR VEHICULOS", client6_msgs, "whatsapp")

        print(f"\n\n✓ {len(self.sessions)} sesiones creadas")
        print(f"sessions: {self.sessions}")

        # esperar que gemini procese todo
        time.sleep(3)

        # ahora analizar todo
        self.full_system_analysis()

def main():
    print("""
╔════════════════════════════════════════════════════════════════╗
║                                                                ║
║           BOB CHATBOT - EXPLOTACION COMPLETA SISTEMA           ║
║                                                                ║
║  este script permite analizar TODO el sistema:                ║
║  - pipeline completo de cada mensaje                          ║
║  - scoring detallado (7 dimensiones)                          ║
║  - historial de conversaciones                                ║
║  - leads con metadata completa                                ║
║  - archivos de datos raw                                      ║
║  - metricas en tiempo real                                    ║
║                                                                ║
╚════════════════════════════════════════════════════════════════╝
""")

    exploiter = BobSystemExploit()

    print("\nopciones:")
    print("  1. stress test + analisis completo (recomendado)")
    print("  2. solo analisis de data actual")
    print("  3. simular cliente custom")

    choice = input("\nelige (1-3): ").strip()

    if choice == "1":
        exploiter.stress_test()
    elif choice == "2":
        exploiter.full_system_analysis()
    elif choice == "3":
        name = input("nombre del cliente: ")
        channel = input("channel (web/whatsapp/test): ")
        messages = []
        print("escribe mensajes (linea vacia para terminar):")
        while True:
            msg = input(f"  mensaje {len(messages)+1}: ")
            if not msg:
                break
            messages.append(msg)

        sid = exploiter.simulate_client(name, messages, channel)
        print(f"\nsession creada: {sid}")

        # ver lead generado
        time.sleep(2)
        lead = exploiter.get_lead(sid)
        print("\nlead generado:")
        print(json.dumps(lead, indent=2, ensure_ascii=False))
    else:
        print("opcion invalida")

if __name__ == "__main__":
    main()
